{"ast":null,"code":"import _objectSpread from \"/home/academy9/\\u0414\\u043E\\u043A\\u0443\\u043C\\u0435\\u043D\\u0442\\u044B/MobX/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { makeAutoObservable } from \"mobx\";\nimport { fetchTasks, handleAddTask, handleDeleteTask, updateTask as apiUpdateTask } from \"../api\";\nclass TodoStore {\n  constructor() {\n    this.tasks = [];\n    this.newTaskText = \"\";\n    this.editingTask = null;\n    this.message = \"\";\n    this.addTask = async () => {\n      if (!this.newTaskText.trim()) return;\n      try {\n        const newTask = await handleAddTask(this.newTaskText);\n        this.tasks.push(newTask);\n        this.newTaskText = \"\";\n      } catch (error) {\n        this.message = \"Failed to add task. Please try again later.\";\n        console.error(error);\n      }\n    };\n    this.deleteTask = async id => {\n      try {\n        await handleDeleteTask(id);\n        this.tasks = this.tasks.filter(task => task.id !== id);\n      } catch (error) {\n        this.message = \"Failed to delete task. Please try again later.\";\n        console.error(error);\n      }\n    };\n    this.toggleTask = async id => {\n      try {\n        const taskIndex = this.tasks.findIndex(task => task.id === id);\n        if (taskIndex === -1) {\n          return;\n        }\n        const updatedTask = _objectSpread(_objectSpread({}, this.tasks[taskIndex]), {}, {\n          completed: !this.tasks[taskIndex].completed\n        });\n        await apiUpdateTask(id, updatedTask);\n        this.tasks[taskIndex] = updatedTask;\n      } catch (error) {\n        this.message = \"Failed to toggle task. Please try again later.\";\n        console.error(error);\n      }\n    };\n    this.markAllCompleted = async () => {\n      try {\n        for (const task of this.tasks) {\n          if (!task.completed) {\n            const updatedTask = _objectSpread(_objectSpread({}, task), {}, {\n              completed: true\n            });\n            await apiUpdateTask(task.id, updatedTask);\n          }\n        }\n        this.tasks = this.tasks.map(task => _objectSpread(_objectSpread({}, task), {}, {\n          completed: true\n        }));\n      } catch (error) {\n        this.message = \"Failed to mark all tasks as completed. Please try again later.\";\n        console.error(error);\n      }\n    };\n    this.deleteCompleted = async () => {\n      try {\n        const completedTasksIds = this.tasks.filter(task => task.completed).map(task => task.id);\n        for (const taskId of completedTasksIds) {\n          await handleDeleteTask(taskId);\n        }\n        this.tasks = this.tasks.filter(task => !task.completed);\n      } catch (error) {\n        this.message = \"Failed to delete completed tasks. Please try again later.\";\n        console.error(error);\n      }\n    };\n    this.updateTask = async updatedTask => {\n      if (updatedTask.text.trim() === \"\") return;\n      try {\n        await apiUpdateTask(updatedTask.id, updatedTask);\n        const taskIndex = this.tasks.findIndex(task => task.id === updatedTask.id);\n        if (taskIndex !== -1) {\n          this.tasks[taskIndex] = updatedTask;\n        }\n        this.editingTask = null;\n      } catch (error) {\n        this.message = \"Failed to update task. Please try again later.\";\n        console.error(error);\n      }\n    };\n    makeAutoObservable(this);\n  }\n  async fetchInitialTasks() {\n    try {\n      const fetchedTasks = await fetchTasks();\n      this.tasks = fetchedTasks;\n      this.message = \"❗Tasks loaded from server❗\";\n    } catch (error) {\n      console.error(\"Error fetching tasks:\", error);\n      this.message = \"❗Error loading tasks❗\";\n    }\n  }\n  startEditingTask(task) {\n    this.editingTask = task;\n  }\n  cancelEditingTask() {\n    this.editingTask = null;\n  }\n  setNewTaskText(text) {\n    this.newTaskText = text;\n  }\n}\nexport default new TodoStore();","map":{"version":3,"names":["makeAutoObservable","fetchTasks","handleAddTask","handleDeleteTask","updateTask","apiUpdateTask","TodoStore","constructor","tasks","newTaskText","editingTask","message","addTask","trim","newTask","push","error","console","deleteTask","id","filter","task","toggleTask","taskIndex","findIndex","updatedTask","_objectSpread","completed","markAllCompleted","map","deleteCompleted","completedTasksIds","taskId","text","fetchInitialTasks","fetchedTasks","startEditingTask","cancelEditingTask","setNewTaskText"],"sources":["/home/academy9/Документы/MobX/src/store/todoStore.ts"],"sourcesContent":["import { makeAutoObservable } from \"mobx\";\nimport { TaskItem } from \"../types\";\nimport { fetchTasks, handleAddTask, handleDeleteTask, updateTask as apiUpdateTask } from \"../api\";\n\nclass TodoStore {\n    tasks: TaskItem[] = [];\n    newTaskText: string = \"\";\n    editingTask: TaskItem | null = null;\n    message: string = \"\";\n\n    constructor() {\n        makeAutoObservable(this);\n    }\n\n    async fetchInitialTasks() {\n        try {\n            const fetchedTasks = await fetchTasks();\n            this.tasks = fetchedTasks;\n            this.message = \"❗Tasks loaded from server❗\";\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            this.message = \"❗Error loading tasks❗\";\n        }\n    }\n\n    addTask = async () => {\n        if (!this.newTaskText.trim()) return;\n\n        try {\n            const newTask = await handleAddTask(this.newTaskText);\n            this.tasks.push(newTask);\n            this.newTaskText = \"\";\n        } catch (error) {\n            this.message = \"Failed to add task. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    deleteTask = async (id: number) => {\n        try {\n            await handleDeleteTask(id);\n            this.tasks = this.tasks.filter((task) => task.id !== id);\n        } catch (error) {\n            this.message = \"Failed to delete task. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    toggleTask = async (id: number) => {\n        try {\n            const taskIndex = this.tasks.findIndex((task) => task.id === id);\n            if (taskIndex === -1) {\n                return;\n            }\n            const updatedTask = { ...this.tasks[taskIndex], completed: !this.tasks[taskIndex].completed };\n            await apiUpdateTask(id, updatedTask);\n            this.tasks[taskIndex] = updatedTask;\n        } catch (error) {\n            this.message = \"Failed to toggle task. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    markAllCompleted = async () => {\n        try {\n            for (const task of this.tasks) {\n                if (!task.completed) {\n                    const updatedTask = { ...task, completed: true };\n                    await apiUpdateTask(task.id, updatedTask);\n                }\n            }\n\n            this.tasks = this.tasks.map((task) => ({ ...task, completed: true }));\n        } catch (error) {\n            this.message = \"Failed to mark all tasks as completed. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    deleteCompleted = async () => {\n        try {\n            const completedTasksIds = this.tasks.filter(task => task.completed).map(task => task.id);\n            for (const taskId of completedTasksIds) {\n                await handleDeleteTask(taskId);\n            }\n\n            this.tasks = this.tasks.filter((task) => !task.completed);\n        } catch (error) {\n            this.message = \"Failed to delete completed tasks. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    startEditingTask(task: TaskItem) {\n        this.editingTask = task;\n    }\n\n    cancelEditingTask() {\n        this.editingTask = null;\n    }\n\n    updateTask = async (updatedTask: TaskItem) => {\n        if (updatedTask.text.trim() === \"\") return;\n\n        try {\n            await apiUpdateTask(updatedTask.id, updatedTask);\n\n            const taskIndex = this.tasks.findIndex((task) => task.id === updatedTask.id);\n            if (taskIndex !== -1) {\n                this.tasks[taskIndex] = updatedTask;\n            }\n            this.editingTask = null;\n        } catch (error) {\n            this.message = \"Failed to update task. Please try again later.\";\n            console.error(error);\n        }\n    };\n\n    setNewTaskText(text: string) {\n        this.newTaskText = text;\n    }\n}\n\nexport default new TodoStore();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}